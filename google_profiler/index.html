
<!DOCTYPE html>
<!-- Copyright (C) 2013 Michael Kosowsky  All rights reserved. -->
<html>
<head>

<title>HeyWhatsThat Path Profiler</title>

<meta name="description" content="Compute elevation profile for an arbitrary path">
<meta name="keywords" content="geography, bicycling, running, GPS, maps, jag, contours, elevation, profile, google maps">

<style type="text/css">
  html { height: 100% }
  body { height: 100%; margin: 0; padding: 4px }
  body { font-family: Arial,sans-serif; font-size: 13px }
  .button { color: blue; cursor: pointer; padding: 0px 5px; -moz-user-select: none; }
  .button_ul { color: blue; cursor: pointer; text-decoration: underline; padding: 0px 5px; -moz-user-select: none; text-align: right }
  .button_ul_no_padding { color: blue; cursor: pointer; text-decoration: underline; -moz-user-select: none; text-align: right }
  :hover.button_ul { color: black }
  .checkbox_text { color: blue; padding: 0px 5px; -moz-user-select: none; text-align: right }
  .button_comment { color: blue; cursor: pointer; padding: 0px 10px; text-align: right; -moz-user-select: none; font-style: italic }
  .emphasize_faq { color: red; cursor: pointer; /*text-decoration: none*/ }
  .maintitle { font-weight: bold; font-size: 24px }
  .bigtitle { font-weight: bold; font-size: 17px }
  .littletitle { font-weight: normal; font-size: 13px }
  .inputcomment { font-size: small; font-style: italic; }
  .maplatlon { /*white-space: pre;*/ font-size: small; }
  .error { font-style: italic }
  .opentab { color: blue; font-size: 14px; cursor: pointer; padding: 5px 15px; white-space: pre; border: 2px solid #d0d0d0; border-bottom-width: 0; background-color: #ffffff; -moz-user-select: none; /* border-top-left-radius: 10px; border-top-right-radius: 10px */ }
  .closedtab { color: blue; font-size: 14px; cursor: pointer; padding: 5px 15px; white-space: pre; border: 2px solid #d0d0d0; background-color: #f0f0f0; -moz-user-select: none; /* border-top-left-radius: 10px; border-top-right-radius: 10px */ }
  .betweentabs { padding: 3px; border-bottom: 2px solid #d0d0d0; }
  :hover.opentab { color: black }
  :hover.closedtab { color: black }
  .tabselect { color: blue; cursor: pointer; text-decoration: none; -moz-user-select: none }
  .queryheading { font-style: italic; font-size: 14px; padding: 10px 0px; color: #c60205 }
  .ads { padding: 20px }
  #v3_msg { font-weight: normal; font-size: 13px; padding: 3px; border: none; font-style: italic }
</style>

<script type="text/javascript" src="http://maps.google.com/maps/api/js?sensor=false"></script>
<script src="utils-angle-request6.js" type="text/javascript"></script>
<script src="mapcontrols.js" type="text/javascript"></script>

<!--OLD
 using google loader for gdata and inset ads and earth API
<script type="text/javascript" src="http://www.google.com/jsapi?key=ABQIAAAAxsqYw7B7eI0V6zTFWKBGpxQ_UwQ4VMio0ceMZbwdsElh38aF7xQFQhFPap3IfXtp6xyYSPS3sQgaBg"></script>
<script type="text/javascript">
  google.load("ads", "1.0");	// inset ads
		  // for load_msid().  tried dynamically loading this only if load_msid() used, but callback appears broken ...
  google.load("gdata", "2.x", { packages: ['maps'] });
  var use_ge = word_param('earth') - 0; //!(word_param("noearth") - 0);
  if (use_ge) {
    google.load("earth", "1");
    document.writeln('<scr' + 'ipt src="http://earth-api-utility-library.googlecode.com/svn/tags/extensions-0.1.2/dist/extensions.pack.js"> </scr' + 'ipt>');
  }

inset ad:
  var insetAd = new google.ads.MapInsetAd(map, "pub-2630458079197795", { ad_channel: "5484073291" });
</script>
-->

<script>

var $m = google.maps;
//$m.event.addDomListener(window, 'load', go);

var map;
var ge;
var gex;
var use_ge = 0;

var map_div;
var map_latlon_div;
var bearing_div;
var list_div;
var list_pane;
var error_pane;
var transect0_pane;
var transect1_pane;
var units_radio;
var contour_overlay;

var max_smooth_direction_points = 50;
		// set to zero for unlimited (seems to be roughly 250)
if (word_param('maxdirections'))
  max_smooth_direction_points = word_param('maxdirections') - 0;

var edit3d;


	// plus sign is current cursor (e.g. lat/lon for next query)
var icon_plus = {
  url: 'images/black-plus.png',
  anchor: new $m.Point(12, 12)
}
//var icon_plus_anchorpoint = new $m.Point(0, -7);




function go() {
  map_div        = $$("map_div");
  map_latlon_div = $$("map_latlon_div");
  bearing_div    = $$("bearing_div");
  list_div       = $$("list_div");
  list_pane      = $$("list_pane");
  error_pane     = $$("error_pane");
  transect0_pane = $$("transect0_pane");
  transect1_pane = $$("transect1_pane");
  units_radio    = document.f_units.units;

  // $$('v3_msg_mailto2').href = "mailto:profiler-v3@hey" + '' + 'whatsthat.com';

	// until 8/2016, you can get old gmaps controls
  if (boolean_param('azteca'))
    $m.controlStyle = 'azteca';

  map = new $m.Map($$('map_div'), {
    zoom:                      2,
    center:                    new $m.LatLng(0, 0),
    draggableCursor:           'crosshair',
    mapTypeId:                 $m.MapTypeId.ROADMAP,
					// default is all 4 types, e.g. mapTypeControlOptions: { mapTypeIds: [ $m.MapTypeId.ROADMAP, $m.MapTypeId.HYBRID, $m.MapTypeId.SATELLITE, $m.MapTypeId.TERRAIN ] },
    overviewMapControl:        true,
    overviewMapControlOptions: { opened: true },
    scaleControl: true  
  });
  current.overviewmap = 1;

  if (navigator.geolocation && !boolean_param('no_geolocate'))
    navigator.geolocation.getCurrentPosition(
      function(pos) {
        map.setZoom(8);
	map.panTo(new $m.LatLng(round6(pos.coords.latitude), round6(pos.coords.longitude)));
      },
      null,
      { enableHighAccuracy: false, timeout: 10000, maximumAge: 600000 }
    );


  if (use_ge && google.earth.isSupported()) {
    map.addMapType(G_SATELLITE_3D_MAP);
    map.getEarthInstance(function(_ge) {
      if (!_ge)		// BUG: this can be null ??  IE8
        return;
      ge = _ge;
      gex = new GEarthExtensions(ge);
      google.earth.addEventListener(ge.getView(), "viewchangeend", ge_viewchange);
      google.earth.addEventListener(ge.getGlobe(), "mousedown", ge_mousedown);
      google.earth.addEventListener(ge.getGlobe(), "click", ge_click);
      ge.getLayerRoot().enableLayerById(ge.LAYER_TERRAIN, true);
      //ge.getLayerRoot().enableLayerById(ge.LAYER_ROADS, true);
    });
  }

  $m.event.addListener(map, 'click', function(e) { add_point_drv(round6(e.latLng.lat()), round6(e.latLng.lng())); draw_transects(); });
  $m.event.addListener(map, 'mousemove', function(e) { update_latlon_div(round6(e.latLng.lat()), round6(e.latLng.lng())); });

  contour_overlay = new ContourOverlay('profiler', $m.ControlPosition.TOP_RIGHT);

  read_settings_cookie();
  set_units(settings.use_metric);
  set_degrees_format(settings.degrees_format);
  set_show_grade(word_param('show_grade') - 0);
  set_show_rise(word_param('show_rise') - 0);
  set_include_grade(word_param('include_grade')? word_param('include_grade') - 0 : 1);
  set_driving_route(0);
  current.print_comments = boolean_param('printcomments');
//set_curvature(  word_param('curvature')  - 0);

        // possibly override cookie; allow both 'metric' and 'units' because 'metric' is in our profiler API
  if (word_param('metric'))
    set_units(word_param('metric') - 0);
  if (word_param('units'))
    set_units(word_param('units') - 0);
  if (word_param('df'))
    set_degrees_format(word_param('df') - 0);
  if (word_param('decimal_places'))
    set_decimal_places(word_param('decimal_places') - 0);
  else
    set_decimal_places(settings.decimal_places);

  reset_transect_parms(0);
  reset_transect_parms(1);

  wtbutton_set($$('transect0_widget'), 1);
  wtbutton_set($$('transect1_widget'), 0);
  wtbutton_set($$('transect0_parms_widget'), 0);
  wtbutton_set($$('transect1_parms_widget'), 0);

  init_transect();
  clear_points();

	// allow both zero and one -based
  if (decode_param('add0') || decode_param('ll0'))
    parm_index = 0;
	// would be nice to batch all the elevation requests here
  next_parm();

  window.onresize = window_resize;
  init_map_resize();
  //setTimeout(init_map_resize, 1000);
}


function window_resize() {
  $$s('map_div').height = "100%";
  map_resize();
}

function map_resize() {
  $m.event.trigger(map, 'resize');
}


/***
function taller_map(dh) {
  $$s('map_div').height = (map_div.clientHeight + dh) + 'px';
  map_resize();
}

function wider_map(dw) {
  $$s('map_div').width = (map_div.clientWidth + dw) + 'px';
  map_resize();
}
***/

		// http://www.wolfpil.de/v2/map-in-a-box.html and ys.lizndom.com/DynamicallyResizeGoogleMapsWithMouse.html
var resizing = false;
function init_map_resize() {
  var resize_corner = document.createElement("img");
  resize_corner.title          = "Drag corner to resize the map; double click to toggle overview map";
  resize_corner.src            = "images/map-resize-corner.png";
  resize_corner.style.position = "absolute";
  resize_corner.style.right    = '0px';
  resize_corner.style.bottom   = '0px';
  resize_corner.style.zIndex   = 1000;
  resize_corner.onmousedown    = function() { last_mouse_x = null; resizing = true;  return false; };
  resize_corner.ondblclick     = function() { current.overviewmap = !current.overviewmap; map.setOptions({ overviewMapControl: current.overviewmap }); }
  map_div.appendChild(resize_corner);

  document.onmouseup           = function() { last_mouse_x = null; resizing = false; };
  document.onmousemove         = function(e) {
    if (!resizing)
      return false;
    e = e || window.event;
    mouse_x = e.clientX + (window.scrollX || document.documentElement.scrollLeft || 0);
    mouse_y = e.clientY + (window.scrollY || document.documentElement.scrollTop  || 0);
    if (last_mouse_x != null) {
      var dx = mouse_x - last_mouse_x;
      var dy = mouse_y - last_mouse_y;
      var w  = map_div.clientWidth  + dx;
      var h  = map_div.clientHeight + dy;
      if (w < 100) w = 100;
      if (h < 100) h = 100;
      map_div.style.width  = w + "px";
      map_div.style.height = h + "px";
      map_resize();
    }
    last_mouse_x = mouse_x;
    last_mouse_y = mouse_y;
    return false;
  };
}



	// because geocoding is asynchronous, we can't just loop through the parms all at once
var parm_index = 1;
function next_parm() {
  var s;
  if (s = decode_param('add' + parm_index)) {
    parm_index++;
    add_location(s, next_parm);
  } else if (s = decode_param('ll' + parm_index)) {
    var a = s.split(',');
    if (a[2])
      if (a[2].charAt(0) == '+')
        add_point(a[0] - 0, a[1] - 0, null, null, null, a[2].substr(1) - 0);
      else
        add_point(a[0] - 0, a[1] - 0, null, null, a[2] - 0);
    else
      add_point(a[0] - 0, a[1] - 0);

    parm_index++;
    next_parm();
  }
}


					//************************** GENERIC UI

var DR_NONE      = 0;
var DR_SMOOTH    = 1;
var DR_PIECEWISE = 2;

var current = {
  points: [],
  total_dist: 0,
  show_grade: 0,
  show_rise: 0,
  include_grade: 0,
  elev_source: 0,
  driving_route: 0,
  print: 0,
  print_comments: 0,
  overviewmap: 1
};


var colors = [ 'ff0000', '00c000', '0000ff' ];

function backspace() {
  if (current.points.length == 0)
    return;
  if (current.points.length == 1) {
    clear_points();
    return;
  }
  var p = current.points.pop();
  remove_from_map(p.marker);
  if (p.leg) {
    remove_leg_lines(p);
    current.total_dist -= p.leg.dist;
  }
  write_list_div();
  draw_transects();
}

function clear_points() {
  current.points._foreach(function(p) { if (p.marker) remove_from_map(p.marker); if (p.leg) remove_leg_lines(p); });
  current.points = [];
  current.total_dist = 0;
  write_list_div();
}


function set_show_grade(x) {
  current.show_grade = x;
  document.getElementById('show_grade').checked = x;
  reset_current_points();
}

function set_show_rise(x) {
  current.show_rise = x;
  document.getElementById('show_rise').checked = x;
  reset_current_points();
}

function set_include_grade(x) {
  current.include_grade = x;
  document.getElementById('include_grade').checked = x;
  reset_current_points();
}

function set_driving_route(x, piecewise) {
  current.driving_route = x? piecewise? DR_PIECEWISE : DR_SMOOTH : DR_NONE;
  document.getElementById('driving_route').checked = current.driving_route == DR_SMOOTH;
  //document.getElementById('driving_route_piecewise').checked = current.driving_route == DR_PIECEWISE;
}

function set_degrees_format(x) {
  settings.degrees_format = x - 0;
  radio_set(document.f_units.degrees_format, settings.degrees_format);
  write_settings_cookie();
  update_latlon_div();
  reset_current_points();
}

function set_units(x) {
  settings.use_metric = x - 0? 1 : 0;
  write_settings_cookie();
  radio_set(units_radio, settings.use_metric);
  reset_current_points();
  contour_overlay.redraw();
}

function set_print(p) {
  current.print = p;
  document.getElementById('print').style.display                = p? '' : 'none';
  document.getElementById('nonprint').style.display             = p? 'none' : '';
  document.getElementById('listbutton_div').style.display       = p? 'none' : '';
  document.getElementById('list_pane_form').style.display       = p? 'none' : '';
  reset_current_points();  // in case we need comments fields
}


function reset_current_points() {
  var o = current.points;
  clear_points();
  o._foreach(function(p) { add_point(p.lat, p.lon, p.address, p.leg, p.elev_data, p.elev_override, p.elev_relative, p.pending_route) });
  draw_transects();
}

function update_point_latlon(pt, lat, lon) {
  var o = current.points;
  clear_points();
  o._foreach(function(p) {
    if (p == pt)
      add_point(lat, lon);
    else if (p.prev == pt)
      add_point(p.lat, p.lon, p.address, null, p.elev_data, p.elev_override, p.elev_relative, null);
    else
      add_point(p.lat, p.lon, p.address, p.leg, p.elev_data, p.elev_override, p.elev_relative, p.pending_route);
  });
  draw_transects();
}


function add_point_drv(lat, lon, address) {
  add_point(lat, lon, address, null, null, null, null, current.driving_route);
  if (current.driving_route == DR_SMOOTH)
    get_route(1, current.points[current.points.length - 1]);
  if (current.driving_route == DR_PIECEWISE)
    get_route(0, current.points[current.points.length - 1]);
}


function add_point(lat, lon, address, leg, elev_data, elev_override, elev_relative, pending_route) {
  lat = round6(lat);
  lon = round6(lon);
  var latlng = new $m.LatLng(lat, lon);

  var p = { lat:           lat,
	    lon:	   lon,
	    latlng:        latlng,
	    address:	   address,
	    elev_data:     elev_data,
	    elev_override: elev_override,
	    elev_relative: elev_relative,
	    pending_route: pending_route,
            index:         current.points.length,	// 5/2012 only used in set_elev to find p.next to invalidate p.next.leg.r_f
	    marker:        editing_3d()?
			       null
			     : new $m.Marker({
                                 map:         map,
				 position:    latlng,
				 icon:        icon_plus,
				 //anchorPoint: icon_plus_anchorpoint,
				 clickable:   false,
				 draggable:   true,
				 title:       address? address : format_latlon(lat, lon, 0)
			       })
	  };
  set_elev(p);
  p.html = point_html(p);
  if (p.marker)
    $m.event.addListener(p.marker, 'dragend', function(e) { update_point_latlon(p, round6(e.latLng.lat()), round6(e.latLng.lng())); });

  if (current.points.length > 0) {
    var prev = current.points[current.points.length - 1];
    p.prev = prev;

	// bearing_and_range returns 0 if less than a few cm. separation.  if so, abort the point
    var b = bearing_and_range(prev.lat, prev.lon, lat, lon);
    if (b[1] == 0)
      return;

    var altitude = null;
    if (p.elev != null && prev.elev != null) {
	  // calculate altitude. assumes refraction coefficient .14
      var psi      = b[1] / EARTH_RADIUS;
      var cospsi   = Math.cos(psi);
      var sinpsi   = Math.sin(psi);
      var altitude = 1/DEGREES_TO_RADIANS
                      * (-Math.atan2( ((prev.elev + EARTH_RADIUS) - cospsi * (p.elev + EARTH_RADIUS)),
				                                   (sinpsi * (p.elev + EARTH_RADIUS)) )
                         + .14*psi/2);
    }
    var run  =   (leg && leg.steps && leg.steps.length > 2)? route_run(leg.steps)
							   : b[1];
    var dist =   !current.include_grade?                     run
               : (leg && leg.steps && leg.steps.length > 2)? route_hypotenuse(leg.steps)
               :					     Math.sqrt(b[1] * b[1] + (p.elev - prev.elev) * (p.elev - prev.elev));
    current.total_dist += dist;
    var rb   = bearing_and_range(lat, lon, prev.lat, prev.lon);

    p.leg = { color:           leg?              leg.color : colors[(current.points.length - 1) % colors.length],
	      steps:           leg && leg.steps? leg.steps : [ prev.latlng, p.latlng ],
	      dist:            dist,
              run:             run,
 	      total_dist:      current.total_dist,
	      bearing:         b[0],
	      reverse_bearing: rb[0],
	      altitude:        altitude,
	      r_f:	       leg? leg.r_f : null
    };

    if (current.show_rise) {
      if (p.leg.r_f == null) {

		// create object for the results of the async call to rise.cgi
		// (so it will stick around between calls to reset_current_points)
        p.leg.r_f = { rise: null, fall: null };
        p.leg.total_rise = null;
        p.leg.total_fall = null;
        get_rise_and_fall(p.leg.r_f, prev, p);

      } else {

        if (!prev.leg) {
          p.leg.total_rise = p.leg.r_f.rise;
          p.leg.total_fall = p.leg.r_f.fall;
        } else if (prev.leg.total_rise == null || p.leg.r_f.rise == null) {
  	  p.leg.total_rise = null;
  	  p.leg.total_fall = null;
        } else {
          p.leg.total_rise = prev.leg.total_rise + p.leg.r_f.rise;
          p.leg.total_fall = prev.leg.total_fall + p.leg.r_f.fall;
        }

      }
    }

    p.leg.html = leg_html(p);
    add_leg_lines(p);
  }

  current.points.push(p);
  write_list_div();
}


function point_html(p) {
  return    (p.address? '<tr><td colspan=4><i>' + p.address + '</i></td></tr>' : '')
          + '<tr align=right>'
          + '<td>' + format_lat(p.lat, 1) + '</td>'
          + '<td>' + format_lon(p.lon, 1) + '</td>'
					// HACK using lat and lon to find ourselves if they click on elevation
	  + '<td><span class="button_ul_no_padding" onclick="get_elev_override(' + p.lat + ',' + p.lon + ')">'
          +   (p.elev != null? ft_or_m(p.elev) : '-')
          + '</span></td>'
          +   (p.elev_override != null && p.elev_data != null? 
			'<td>(+' + meters_to_units(p.elev_override - p.elev_data) + ')</td>' : '')
	  + (current.print && current.print_comments? '<td><input type=text size=20></td>' : '')
	  + '</tr>';
}


function leg_html(p) {
  var l = p.leg;
  if (!l)
    return '';
  var start_elev = current.points[0].elev;
  var prev_elev  = p.prev.elev;
  var next_elev  = p.elev;

  return   '<tr align=right style="color: #' + l.color + '">'
         + '<td title="reverse bearing ' + settings.round_bearing(adjust_for_declination(l.reverse_bearing)) + '">'
            + settings.round_bearing(adjust_for_declination(l.bearing)) + '&deg;</td>'
         + '<td>' + miles_or_km1(l.dist) + '</td>'
	 + '<td>' + meters_to_miles_or_km_round(l.total_dist) + '&nbsp;total</td></tr>'
	 + (current.show_grade && next_elev != null && start_elev != null && prev_elev != null?
	        '<tr align=right style="color: #' + l.color + '">' 
              + '<td>' + ft_or_m(next_elev - prev_elev)
                + ' ('
                  + percent1((next_elev - prev_elev)/l.run)
		  + (l.altitude != null? ' ' + degrees1(l.altitude) : '')
                + ')</td>'
	      + '<td>' + meters_to_units_round(next_elev - start_elev) + '&nbsp;total</td></tr>'
            : '')
	 + (current.show_rise && p.leg.r_f.rise != null?
	        '<tr align=right style="color: #' + l.color + '">' 
              + '<td>' + meters_to_units_round(p.leg.r_f.rise) + '/' + ft_or_m(p.leg.r_f.fall) + '</td>'
	      + (p.leg.total_rise != null?
		  '<td>' + meters_to_units_round(p.leg.total_rise) + '/' + meters_to_units_round(p.leg.total_fall) + '&nbsp;total</td>'
		: '')
            : '');
}


function add_leg_lines(p) {
  var l = p.leg;
  if (!l)
    return;
  l.line   = editing_3d()?
               null
             : new $m.Polyline({
                 map:           map,
                 path:          l.steps,
                 strokeColor:   '#' + l.color,
		 strokeWeight:  3,
		 strokeOpacity: .5,
		 geodesic:      true
               });
/*
  l.gc_line = editing_3d()?
               null
             : new $m.Polyline({
                 map:           map,
                 path:          l.steps,
                 strokeColor:   'purple',
		 strokeWeight:  1,
		 strokeOpacity: .5,
		 geodesic:      true
               });
*/
}

function remove_leg_lines(p) {
  var l = p.leg;
  if (l) {
    if (l.line)
      l.line.setMap(null);
    if (l.gc_line)
      l.gc_line.setMap(null);
    l.line    = null;
    l.gc_line = null;
  }
}


function add_steps(p, steps) {
  remove_leg_lines(p);
  var l    = p.leg;
  l.steps  = steps;
  l.run    = route_run(steps);
  var dist = current.include_grade? route_hypotenuse(steps) : l.run;
  l.total_dist += dist - l.dist;
  l.dist   = dist;
  if (current.show_rise)
    get_rise_and_fall(p.leg.r_f, p.prev, p);
  l.html = leg_html(p);
  add_leg_lines(p);
  update_legs(p);
}


function update_legs(start) {
  var i;

  if (start) {
    current.total_dist = start.leg.total_dist;
    //current.total_dist_is_true = start.total_dist_is_true;
    for (i = 0; i < current.points.length && current.points[i] != start; i++) ;
    i++;
  } else {
    current.total_dist = 0;
    //current.total_dist_is_true = true;
    i = 0;
  }
  for (; i < current.points.length; i++) {
    var p = current.points[i];
    var l = p.leg;
    current.total_dist += l.dist;
    //current.total_dist_is_true &= l.dist_is_true;
    l.total_dist = current.total_dist;
    //l.total_dist_is_true = current.total_dist_is_true;
    l.html = leg_html(p);
  }
  write_list_div();
}


function route_run(a) {
  var t = 0;
  for (var i = 0; i < a.length - 1; i++) {
    var b = bearing_and_range(a[i].lat(), a[i].lng(), a[i+1].lat(), a[i+1].lng());
    t += b[1];
  }
  return t;
}

function route_hypotenuse(a) {
  var t = 0;
  for (var i = 0; i < a.length - 1; i++) {
    var b = bearing_and_range(a[i].lat(), a[i].lng(), a[i+1].lat(), a[i+1].lng());
    var y = a[i+1].elev() - a[i].elev();
    t += Math.sqrt(b[1] * b[1] + y * y);
  }
  return t;
}

function get_route(smooth, p) {
  if (p == null || p == current.points[0])
    return;
	// can't trust that the point will still exist when route comes back, so we'll have to search for it
  var lat0 = p.prev.lat;
  var lon0 = p.prev.lon;
  var lat1 = p.lat;
  var lon1 = p.lon;
  wt_async_request_array_of_lines('/bin/directions.cgi?elevs=1'
				    + '&max=' + (smooth? max_smooth_direction_points : 25)
                                    + '&lat0=' + p.prev.lat + '&lon0=' + p.prev.lon + '&lat1=' + p.lat + '&lon1=' + p.lon,
		                  'Directions',
				  function(a) { parse_directions(smooth, lat0, lon0, lat1, lon1, a) });
}


function parse_directions(smooth, lat0, lon0, lat1, lon1, a) {
  var p = find_point_needing_route(smooth? DR_SMOOTH : DR_PIECEWISE, lat0, lon0, lat1, lon1);
	// BUG: relax requirement that it be final point!
  if (!p || (!smooth && p != current.points[current.points.length - 1]))
    return;
  p.pending_route = DR_NONE;

  if (a.length > 2048)
    return;
  if (a.length < 3) {
    alert('No driving route available');
    return;
  }

					// replace start and end with the points we requested
					// (sometimes Google directions don't quite hit the endpoints)
					// and make sure no segments are too short
					// (in particular, this means when adding final point, back up through the array)
  a.pop(); a.unshift();
  var lles = [ [lat0, lon0, p.prev.elev] ];
  var lastlat = lat0;
  var lastlon = lon0;
  a._foreach(function(b) {
     var lle = b.split(' ');
     lle[0] = lle[0] - 0;
     lle[1] = lle[1] - 0;
     lle[2] = lle[2] - 0;
     if (!near(lastlat, lastlon, lle[0], lle[1])) {
       lles.push(lle);
       lastlat = lle[0];
       lastlon = lle[1];
     }
  });
  for (;;) {
    var i = lles.length - 1;
    if (i < 1) {
      alert('No driving route available');
      return;
    }
    if (!near(lat1, lon1, lles[i][0], lles[i][1]))
      break;
    lles.pop();
  }

  if (smooth) {
    steps = [];
    lles.push([p.lat, p.lon, p.elev]);
    lles._foreach(function(lle) { steps.push(new LatLngElev(lle[0], lle[1], lle[2])); });
    add_steps(p, steps);
  } else {
    backspace(); // directions end with this point
    lles._foreach(function(lle) { add_point(lle[0], lle[1], null, null, lle[2]); });
    add_point(p.lat, p.lon, p.address, null, p.elev_data, p.elev_override);
  }

  draw_transects();
}



LatLngElev = function(lat, lon, elev) {
  this._elev = elev;
  $m.LatLng.call(this, lat, lon);
};
derive(LatLngElev, $m.LatLng);

LatLngElev.prototype.elev = function() {
  return this._elev;
}


function find_point_needing_route(type, lat0, lon0, lat1, lon1) {
  for (var i = current.points.length - 1; i > 0; i--) {
    var p = current.points[i];
    if (p.pending_route == type && nearpt(p.prev, lat0, lon0) && nearpt(p, lat1, lon1))
      return p;
  }
  return null;
}


function find_point_by_latlon(lat, lon) {
  for (var i = current.points.length - 1; i >= 0; i--) {
    var p = current.points[i];
    if (p.lat == lat && p.lon == lon)
      return p;
  }
  return null;
}


function get_rise_and_fall(r_f, prev, p) {
  var l = p.leg;

  var s = 'pt0=' + prev.lat + ',' + prev.lon + (prev.elev_override != null? ',' + prev.elev_override : '');
  var k = 1;

  var limit = ((is_msie? 2083 : 8190) - 110 - 37 * 1) / 27 - 5;
  inc = l.steps.length < limit? 1 : 1 + Math.floor((l.steps.length - 1)/limit);

  for (var j = 1; j < l.steps.length - 1; j += inc)
    s += '&pt' + k++ + '=' + l.steps[j].lat() + ',' + l.steps[j].lng();
  s += '&pt' + k + '=' + p.lat + ',' + p.lon + (p.elev_override != null? ',' + p.elev_override : '');

  wt_async_request_array('bin/rise.cgi?' + s,
			 'RISE AND FALL',
			 null,
			 function(a) {
			   if (a.length < 2 && current.show_rise) {
			     alert('Path too long for rise/fall');
			     set_show_rise(false);
			     return;
			   }
			   r_f.rise = a[0] - 0;
			   r_f.fall = a[1] - 0;
			   reset_current_points();
			 }
			);
}


var lastlat;
var lastlon;
function update_latlon_div(lat, lon) {
  if (lat != null && lon != null) {
    lastlat = lat;
    lastlon = lon;
  }
  if (lastlat != null && lastlon != null)
    map_latlon_div.innerHTML = format_latlon(lastlat, lastlon, 1);
}


function write_list_div() {
  if (!current.points.length) {
    list_div.innerHTML = '';
    return;
  }

  var s = '<table>'; // cellpadding="1"
  for (var i = 0; i < current.points.length; i++)
    s += (current.points[i].leg? current.points[i].leg.html : '') + current.points[i].html;
  s += '</table>';
  list_div.innerHTML = s;
}


function add_location(s, callback) {
		// is_address is false if they entered a lat,lon
  geocode(s, function(lat, lon, is_address) {
    add_point_drv(lat, lon, is_address? s : null);
    map.setCenter(new $m.LatLng(lat, lon), 12);
    draw_transects();
    if (callback)
      callback();
    }
  );
}

function handle_location() {
  if (!document.f_list_pane.location.value)
    return;
  add_location(document.f_list_pane.location.value);
}

function checkpoint() {
  var warn = false;
  current.points._foreach(function(p) { if (p.leg && p.leg.steps.length > 2) warn = true; })
  if (warn && !confirm("Sorry, checkpoint can't handle the non-piecewise driving routes and will just checkpoint the endpoints.  Checkpoint anyway?"))
    return;

  var s = '';
  var i = 1;
  current.points._foreach(function(p) {
    s += '&ll' + i + '=' + p.lat + ',' + p.lon
	  + (p.elev_override? ',' + (p.elev_relative? '+' + p.elev_relative : p.elev_override) : ''); //RELATIVE
    i++;
  });

		// use_metric and degrees_format are saved in a cookie
  location.href = 'profiler.html'
		  + '?show_grade='     + current.show_grade
		  + '&show_rise='      + current.show_rise
		  + '&include_grade='  + current.include_grade
                  //+ '&curvature='    + current.curvature
                  + '&decimal_places=' + settings.decimal_places
                  + '&elev_source='    + current.elev_source
                  + (boolean_param('no_geolocate')? '&no_geolocate=1' : '')
                  + s;
}


function add_points_from_kml(kml) {
	// not sure what happens if you combine //g with parentheses across browwsers, so being a bit pendantic
  var a = kml.replace(/[\s\r\n]+/g, ' ').match(/<coordinates>.*?<\/coordinates>/g);
  var sc = 1;
  if (a) {
    a._foreach(function(b) {
      var c = b.match(/<coordinates>\s*(.*?)\s*<\/coordinates>/);
      if (c && c[1]) {
        c[1].split(' ')._foreach(function(d) {
	  var e = d.split(',');
	  add_point(e[1], e[0]);
	  if (sc) {
	    map.setCenter(new $m.LatLng(e[1], e[0]), 12);
	    sc = 0;
          }
        });
      }
    });
    draw_transects();
  }
}

/********--TK

function topo_maptype() {
		// use Microsoft Research Map's WMS server
		// inspired by http://roadlessland.org/js/wms236.js John Deck, UC Berkeley
		// and http://roadlessland.org/notes/wms-usgs-example.html
  return new GMapType([
    TileLayer(1, 17,
	      '', 'Topo maps courtesy <a href="http://www.usgs.gov">USGS</a> via <a href="http://msrmaps.com">MRS Maps</a>',
	      function(pt, zoom) {

			// using fromPixelToLatLng is very clever; cf. bin/gmt.cgi for Perl code to do the conversion
      var ul = G_NORMAL_MAP.getProjection().fromPixelToLatLng(new GPoint(256 *  pt.x,      256 * (pt.y + 1)), zoom);
      var lr = G_NORMAL_MAP.getProjection().fromPixelToLatLng(new GPoint(256 * (pt.x + 1), 256 *  pt.y     ), zoom);

      return   "http://www.terraserver-usa.com/ogcmap6.ashx"  // was "http://msrmaps.com/ogcmap.ashx"
             + "?version=1.1.1"
             + "&request=GetMap"
             + "&layers=DRG"				      // DRG or DOQ or UrbanArea
             + "&styles=default"                              // "Geo Grid Dark Golden"
             + "&srs=EPSG:4326"                               // 4326 is WGS84 (Plate-Carree?)
  							      //    cf. http://spatialreference.org/ref/epsg/4326/
  							      // 269xx are UTM in various zones
  							      // 3785 and 9000913 are said to be spherical mercator
  							      //  (used by gmaps: mercator on a sphere, rather than an ellipse)
             + "&bbox=" + [ul.x, ul.y, lr.x, lr.y].join(",")  // lon,lat (specification is x,y)
             + "&width=256"
             + "&height=256"
             + "&format=image/jpeg"
             + "&exceptions=se_inimage";
  	     // other fields  &service=wms &reaspect=false &bgcolor=0xffffff &transparent=true &groupname=drg  &crs (in v1.3.0)
    })
    ], G_NORMAL_MAP.getProjection(), "Topo", { alt: "Show USGS topo maps" });
}
***********/

					//***************************** TRANSECTS
function init_transect() {
    document.getElementById('transect0_img').src = 'images/profile-hit-calculate.png';
    document.getElementById('transect1_img').src = 'images/profile-hit-calculate.png';
}

function draw_transects() {
   if (transect0_pane.style.display != 'none')
     draw_transect(0);
   if (transect1_pane.style.display != 'none')
     draw_transect(1);
}

function draw_transect(n, warn) {
  if (current.points.length < 2) {
    if (warn)
      alert("Click on at least two points,\nthen hit 'calculate'");
    return;
  }

  var form = eval('document.f_transect' + n);

	// consider URL length limits: Apache 8190 and IE 2083
	// 110 bytes address and args
	// 37 for each anchor point
	// 27 for each intermediate point
	// reduce by 5 for safety

  var limit = ((is_msie? 2083 : 8190) - 110 - 37 * current.points.length) / 27 - 5;
  if (limit <= 0) {
    alert("Too many points to draw profile");
    return;
  }
  var t = 0;
  current.points._foreach(function(p) { var l = p.leg; if (l) t += l.steps.length - 2; });
  var inc = t < limit? 1 : 1 + Math.floor((t - 1)/limit);

  var s = '';
  var k = 0;
  for (var i = 1; i < current.points.length; i++) {
    var p = current.points[i].prev;
    var l = current.points[i].leg;
    s += '&pt' + k++ + '=' + p.lat + ',' + p.lon + ',' + (form.colored_lines.checked? l.color : '') + (p.elev_override != null? ',' + p.elev_override : '');
    for (var j = 1; j < l.steps.length - 1; j += inc)
      s += '&pt' + k++ + '=' + l.steps[j].lat() + ',' + l.steps[j].lng();
  }
  var p = current.points[current.points.length - 1];
  s += '&pt' + k++ + '=' + p.lat + ',' + p.lon + (p.elev_override != null? ',,' + p.elev_override : '');


  var yrange = '';
  if (form.yrange.value) {
    var a = form.yrange.value.split(',');
    yrange = units_to_meters(a[0]) + ',' + units_to_meters(a[1]);
  }

  document.getElementById('transect' + n + '_img').src =
	  '/bin/profile-0904.cgi?src=profiler-0904'
	+ (radio_get(form.curvature) - 0? '&curvature=1' : '')
	+ (form.axes.checked? '&axes=1' : '')
	+ (radio_get(form.los) - 0? '&los=1' : '')
	+ (radio_get(form.path) - 0? '&greatcircle=1' : '')
	+ '&metric=' + settings.use_metric
	+ '&freq=' + form.freq.value
	+ '&refraction=' + form.refraction.value
	+ '&exaggeration=' + form.exaggeration.value
	+ (yrange? '&yrange=' + yrange : '')
	+ (radio_get(form.elev_source) - 0? '&elev_source=1' : '')
	+ s;
}


function reset_transect_parms(n) {
  var form = eval('document.f_transect' + n);
  form.axes.checked = 1;
  form.colored_lines.checked = 1;
  radio_set(form.curvature, 0);
  radio_set(form.path, 1);
  radio_set(form.los, 0);
  form.freq.value = "";
  form.refraction.value = "";
  form.exaggeration.value = "";
  form.yrange.value = "";
  radio_set(form.elev_source, 0);
  draw_transect(n);
}

function set_elev_source(n) {
  var form = eval('document.f_transect' + n);

  if (radio_get(form.elev_source) - 0) {
		// Google elevation web service
    radio_set(form.path, 1);
    radio_disable(form.path, 1);

  } else {
    radio_disable(form.path, 0);
  }

  check_elev_sources();
}


function radio_disable(r, v) {
  for (var i = 0; i < r.length; i++)
    r[i].disabled = v;
}




					//***************************** DECIMAL PLACES
function set_decimal_places(n) {
  settings.decimal_places = Math.floor(n - 0);
  write_settings_cookie();
  set_rounding(settings.decimal_places);
  document.f_units.decimalplaces.value = settings.decimal_places;
  reset_current_points();
}


					//**************************** ELEVATION DATA

// CLARIFICATION: we hold on to elev_relative only until we get the elev_data, then we roll it into elev_override
// BUG: this doesn't work now that we allow multiple data sources (ie. want to keep notion of relative elev)

function set_elev(p) {
  if (p.elev_data == null && p.elev_override == null)
    p.elev_data = get_elev_data(p.lat, p.lon);

  if (p.elev_relative != null && p.elev_data != null) {
		// setting relative to zero is NOT an override (we may do it when we leave ge-api edit mode)
    if (p.elev_relative != 0)
      p.elev_override = p.elev_data + p.elev_relative;
    p.elev_relative = null; //RELATIVE
  }

  p.elev = p.elev_override != null? p.elev_override : p.elev_data;
  if (p.leg)
    p.leg.r_f = null;
  var p_next = current.points[p.index + 1];
  if (p_next && p_next.leg)
    p_next.leg.r_f = null;
}

function get_elev_override(lat, lon) {
  var p = find_point_by_latlon(lat, lon);
  if (!p)
    return;

  var e = prompt(p.elev_data != null?
		     "Enter elevation (precede with '+' if relative to ground; ground is " + ft_or_m(p.elev_data) + ")"
	           : "Enter elevation relative to sea level",
		 p.elev_relative? '+' + meters_to_units(p.elev_relative) //RELATIVE
	         : p.elev_override? meters_to_units(p.elev_override)
	         : '');
  if (e == null)
    return;

  var a;
  if ((a = e.match(/^\s*(\+?)\s*(-?[\.\d]+)$/)) && a[0]) {
    var x = round2(units_to_meters(a[2] - 0));
    if (a[1] == '') {
      p.elev_override = x;
      p.elev_relative = null;
    } else {
      p.elev_override = null;
      p.elev_relative = x;
    }
  } else {
    p.elev_override = null;
    p.elev_relative = null;
  }
  set_elev(p);
  p.html = point_html(p);
	// BUG: just redo from here on, not the whole thing
  reset_current_points();
}


var elevs = new Object;

function elev_request(s) {
	// reverse engineers: DON'T use my server's points-google.cgi; it's a service Google describes at
	//  http://code.google.com/apis/maps/documentation/elevation/ and http://code.google.com//apis/maps/documentation/v3/services.html#Elevation
  wt_async_request_array_of_lines('bin/' + (current.elev_source? 'points-google' : 'points') + '.cgi?' + s, 'Elevation', receive_elev);
}


function get_elev_data(lat, lon) {
  if (elevs[lat + ' ' + lon] != null)
    return elevs[lat + ' ' + lon];
  elev_request('&lat0=' + lat + '&lon0=' + lon);
  return null;
}

function check_elev_sources() {
  document.getElementById('google_options_div').style.display =
  	   transect0_pane.style.display == '' && radio_get(document.f_transect0.elev_source) - 0
  	|| transect1_pane.style.display == '' && radio_get(document.f_transect1.elev_source) - 0? '' : 'none';

	// in the list, we show elevations corresponding to the first open transect pane
  var elev_source =   transect0_pane.style.display == ''? radio_get(document.f_transect0.elev_source) - 0
                    : transect1_pane.style.display == ''? radio_get(document.f_transect1.elev_source) - 0
		    : 0;
  if (current.elev_source != elev_source) {
    current.elev_source = elev_source;
    document.getElementById('elev_source_div').innerHTML = current.elev_source? 'Google elevation data' : 'SRTM elevation data';
    reread_elevs();
  }
}


function reread_elevs() {
  elevs = new Object;
  var s = '';
  var i = 0;

  current.points._foreach(function(p) {
    p.elev_data = null;
    if (p.elev_relative)
      p.elev_override = null;
    s += '&lat' + i + '=' + p.lat + '&lon' + i + '=' + p.lon;
    i++;
  });
  if (s)
    elev_request(s);
    // receive_elev() will reset_current_points() once data arrives
}


function receive_elev(a) {
  if (a.length > 100)
    return;
	// points.cgi returns lat/lon with 6 digits of precision, including trailing zeroes,
	// but round6() strips trailing zeroes and that's what we've stored in p.lat and p.lon 
	// (and points-google.cgi may return more digits)
  a._foreach(function(b) { var c = b.split(' '); if (c.length == 3) elevs[round6(c[0]) + ' ' + round6(c[1])] = c[2] - 0; });
  check_elevs();
}

function check_elevs() {
  var got_one = 0;
  current.points._foreach(function(p) {
    var e;
    if (p.elev_data == null && (e = elevs[p.lat + ' ' + p.lon]) != null) {
      p.elev_data = e;
      //if (p.elev_relative) redraw = 1;
      set_elev(p);
      //p.html = point_html(p);
      got_one = 1;
    }
  });

  if (got_one)
		// BUG: just redo from first point on, not the whole thing
		// BUG: don't redraw transect if our now knowing the elevation doesn't affect the profile
    reset_current_points();
}


					//******************** Google Maps Data API

function import_url_or_msid() {
  var url = document.f_import.url.value;

// Don't remember why we needed this hack; if necessary, add another button to the import form
//  if (!url) {
//    google.accounts.user.logout();
//    return;
//  }

  var a;
  a = url.match(/(^|msid=\s*)([a-f\d]+)\.([a-f\d]+)/i);
  if (a && a[2] && a[3]) {
    load_msid(a[2], a[3]);
    return;
  }

  document.f_import.elev_source.value = current.elev_source;
		// rough limit; (is_msie? 2000 : 8000) / 37
  document.f_import.max_points.value  = is_msie? 50 : 200;

  var es = current.elev_source;
  var sc = 1;

  wt_async_request_post_succeed_fail(
    'bin/get-path-from-kml.cgi',
    new FormData(document.f_import),
    function(s) {
      var a = s.split('\n');
      if (a.length)
	a.pop();
      if (!a.length) {
        alert('No points found');
        return;
      }
      a._foreach(function(s) {
        var t = s.match(/(-?[\d\.]+) (-?[\d\.]+) (-?[\d\.]+)/);
        if (t) {
					// make sure user didn't change data source while we were waiting
          add_point(t[1], t[2], null, null, (current.elev_source == es? t[3] : null));
          if (sc) {
	    map.setCenter(new $m.LatLng(t[1], t[2]), 12);
	    sc = 0;
	  }
        }
      });
      draw_transects();
    },
    function() {
      alert("Import failed");
    }
  );


/*
  wt_async_request_array_of_lines('bin/get-path-from-kml.cgi?url=' + url + '&elev_source=' + current.elev_source,
	      'KML PATH', function(a) {
		a._foreach(function(s) {
	          var t = s.match(/(-?[\d\.]+) (-?[\d\.]+) (-?[\d\.]+)/);
		  if (t) {
					// make sure user didn't change data source while we were waiting
		    add_point(t[1], t[2], null, null, (current.elev_source == es? t[3] : null));
		    if (sc) {
		      map.setCenter(new $m.LatLng(t[1], t[2]), 12);
		      sc = 0;
		    }
		  }
		});
	        draw_transects();
              });
*/

}


var gmapsdata_service;
var MAPS_SCOPE = 'http://maps.google.com/maps/feeds/';

function load_msid(user, map) {

/***
  GMAPSDATA BUG: couldn't get dynamically loading the gdata lib with callback to work;
                 the subsequent checkLogin() would always return false and lead
		 to never-ending trips to google accounts
  if (!gmapsdata_service) {
    gmapsdata_onload_callback = function() { load_msid(user, map); };
    google.load('gdata', '2.x', { packages: ['maps'] , callback: function() {
      gmapsdata_service = new google.gdata.maps.MapsService('profiler');
      load_msid(user, map);
    }});
    return;
  }
****/

  if (!gmapsdata_service)
    gmapsdata_service = new google.gdata.maps.MapsService('profiler');

  if (!google.accounts.user.checkLogin(MAPS_SCOPE)) {
    alert('Log in to Google, then re-enter your request');
		// this doesn't return; Google handles login then redirects back to this page, setting cookie
    google.accounts.user.login(MAPS_SCOPE);
    return;
  }

  gmapsdata_service.getMapEntry(
    'http://maps.google.com/maps/feeds/maps/' + user + '/full/' + map + '?alt=json',
    function(entryRoot) {
      feature_feed = entryRoot.entry.getContent().getUri();
      gmapsdata_service.getFeatureFeed(
	feature_feed,
	function(feedRoot) {
	  var features = feedRoot.feed.getEntries();
	  features._foreach(function(f) { add_points_from_kml(f.getContent().getText()); });
        },
	gmapsdata_error);
     },
     gmapsdata_error);
}


function gmapsdata_error(e) {
   alert('gmaps data error: ' + (e.cause ? e.cause.statusText : e.message));
}



					//***************************** MISCELLANEOUS


function percent1(x) {
  return (x * 100).toFixed(Math.max(settings.decimal_places, 1)) + '%';
}

function degrees1(x) {
  return x.toFixed(Math.max(settings.decimal_places, 1)) + '&deg;';
}


var DEGREES_TO_RADIANS = Math.PI / 180.;
var EARTH_RADIUS = 6372798;  // was 6367447;

function bearing_and_range(lat0, lon0, lat1, lon1) {
	// rotate so viewer at zero longitude
  lon1 -= lon0;

	// about 11cm.  prevents NaN values below
  if (Math.abs(lat1 - lat0) + Math.abs(lon1) < .000001)
     return [0, 0];

  lat0 *= DEGREES_TO_RADIANS;
  lat1 *= DEGREES_TO_RADIANS;
  lon1 *= DEGREES_TO_RADIANS;

  var sinlon1 = Math.sin(lon1);
  var coslon1 = Math.cos(lon1);
  var sinlat0 = Math.sin(lat0);
  var coslat0 = Math.cos(lat0);
  var sinlat1 = Math.sin(lat1);
  var coslat1 = Math.cos(lat1);

  var x = coslat1 * coslon1;
  var y = coslat1 * sinlon1;
  var z = sinlat1;

	// rotate about y axis so viewer at north pole
  var xx =  x * sinlat0 - z * coslat0;
  var yy =  y;
  var zz =  x * coslat0 + z * sinlat0;

  var theta = Math.PI - Math.atan2(yy, xx);
  var phi   = Math.acos(zz);
  return [ theta/DEGREES_TO_RADIANS, phi * EARTH_RADIUS];
}


function adjust_for_declination(d) {
/*
  if (settings.magnetic) {
    d -= current.declination;
    if (d < 0)
       d += 360;
    else if (d > 360)
       d -= 360;
  }
*/
  return d;
}

function scroll_if_needed(e, div) {
  var i = e.offsetTop - div.scrollTop;
  if (i < 0)
    e.scrollIntoView();
  else if (i > parseInt(div.style.height) - 23)
    e.scrollIntoView(false);
}


// hack to add overlay of feature data (until we implement it right)

var icon_data = {
  url: 'images/blue-plus.png',
  anchor: new $m.Point(6, 6)
}
//var icon_data_anchorpoint = new $m.Point(0, -6);

function getnamesdata() {
  var b = map.getCenter();
  wt_async_request_array_of_lines('bin/namesdata.cgi?lat0=' + b.lat() + '&lon0=' +  b.lng(),
	      'NAMES DATA',
              function(a) {
		a._foreach(function(s) {
	          var t = s.match(/(-?[\d\.]+) (-?[\d\.]+) ([\-\d]+) \S+ \S+ (.*)/);
		  if (t)
		    new $m.Marker({
                       map:         map,
		       position:    new $m.LatLng(t[1], t[2]),
		       icon:        icon_data,
		       //anchorPoint: icon_data_anchorpoint,
		       clickable:   false,
		       title:       ft_or_m(t[3]) + ' ' + t[4]
		    });
                });
              });
}


/**************************
// simplify adding hacks (cf. http://www.elsewhere.org/journal/gmaptogpx)
// just need a bookmark that looks like 'javascript:addon("hack.js")'

function addon(s) {
  var script = document.createElement('script');
  script.src = s;
  document.getElementsByTagName('head')[0].appendChild(script);
}
*****************************/

/*********

function window_width() {
  return(   (window.self?              window.self.innerWidth               : 0)
	 || (document.documentElement? document.documentElement.clientWidth : 0));
}

function window_height() {
  return(   (window.self?              window.self.innerHeight               : 0)
	 || (document.documentElement? document.documentElement.clientHeight : 0));
}

function element_offset_top(element, base) {
  var o = 0;
  for (var e = element; e && e != base; e = e.offsetParent)
    o += e.offsetTop;
  return o;
}

function element_width(e) {
  return style_px(e, 'width');
}

function element_height(e) {
  return style_px(e, 'height');
}

function style_px(e, attr) {
  var a = e.style[attr].match(/(\d+)/);
  return a && a[0]? a[0] - 0 : 0;
}

function element_width(e) {
  return e.clientWidth;
}

function element_height(e) {
  return e.clientHeight;
}


function set_mapdiv_size() {
var sss = [element_width(map_div)+'=', window_width(), element_width(list_div), 'xxx', element_height(map_div)+'=', window_height(), element_offset_top(map_div), element_height(error_pane)].join(' ');
  var w = window_width()  - element_width(list_pane) - 50;
  var h = window_height() - element_offset_top(map_div) - element_height(error_pane) - 50;
return;
  if (w > 0)
    map_div.style.width = w + 'px';
  if (h > 0)
    map_div.style.height = h + 'px';
}

*************/



/********
		// http://www.wolfpil.de/v2/map-in-a-box.html and ys.lizndom.com/DynamicallyResizeGoogleMapsWithMouse.html
var resizing = false;
var last_mouse_x;
var last_mouse_y;

function init_map_resize() {
  var resize_corner = document.createElement("img");
  resize_corner.src            = "images/map-resize-corner.png";
  resize_corner.style.position = "absolute";
  resize_corner.style.right    = '0px';
  resize_corner.style.bottom   = '0px';
  resize_corner.onmousedown    = function() { last_mouse_x = null; resizing = true;  return false; };
  map_div.appendChild(resize_corner);

  document.onmouseup           = function() { last_mouse_x = null; resizing = false; };
  document.onmousemove         = function(e) {
    if (!resizing)
      return false;
    e = e || window.event;
    mouse_x = e.clientX + (window.scrollX || document.documentElement.scrollLeft || 0);
    mouse_y = e.clientY + (window.scrollY || document.documentElement.scrollTop  || 0);
    if (last_mouse_x != null) {
      var dx = mouse_x - last_mouse_x;
      var dy = mouse_y - last_mouse_y;
      var w  = parseInt(map_div.style.width) + dx;
      var h  = parseInt(map_div.style.height) + dy;
      if (w < 100) w = 100;
      if (h < 100) h = 100;
      map_div.style.width  = w + "px";
      map_div.style.height = h + "px";
      map.checkResize();
    }
    last_mouse_x = mouse_x;
    last_mouse_y = mouse_y;
    return false;
  };
}
***********/

function show_popup(div, width_guess, height_guess) {
/*
  get window_height() and window_width() and height() and width() from wisp/index.html

  var h = window_height();
  $$s('cloak_div').height = h + 'px';
  $$s('cloak_div').display = '';

  div.style.top = (h - height(div, height_guess))/2 + 'px';
  div.style.left = (window_width() - width(div, width_guess))/2 + 'px';
*/
  div.style.display = '';
}

function close_popup(div) {
/*
  $$s('cloak_div').display = 'none';
*/
  div.style.display = 'none';
}


/************************ GE API *********************/

var was_3d = false;
var linestring_placemark;
var linestring_timeout_id;

function ge_viewchange() {
  var now_3d = (map.getCurrentMapType() == G_SATELLITE_3D_MAP);
  if (now_3d && !was_3d) {
    was_3d = true;
    edit3d.enable();
  } else if (!now_3d && was_3d) {
    was_3d = false;
    edit3d.disable();
    edit3d.reset();
    finish_3d_edit();
  }
}


  /******
  var targetType = kmlEvent.getTarget().getType();
  var currentTargetType = kmlEvent.getCurrentTarget().getType();
  var button = kmlEvent.getButton());
  var clientX = kmlEvent.getClientX();
  var clientY = kmlEvent.getClientY();
  var screenX = kmlEvent.getScreenX();
  var screenY = kmlEvent.getScreenY();
  var latitude = kmlEvent.getLatitude();
  var longitude = kmlEvent.getLongitude();
  var altitude = kmlEvent.getAltitude();
  var didHitGlobe = kmlEvent.getDidHitGlobe();
  var altKey = kmlEvent.getAltKey();
  var ctrlKey = kmlEvent.getCtrlKey();
  var shiftKey = kmlEvent.getShiftKey();
  var timeStamp = kmlEvent.getTimeStamp();
  *****/

var mousedown_at;
function ge_mousedown(kmlEvent) {
  mousedown_at = kmlEvent.getTimeStamp();
}

function ge_click(kmlEvent) {
	// make sure it was a quick click (and not a drag of the globe)
  if (!linestring_placemark && mousedown_at && kmlEvent.getTimeStamp() - mousedown_at < 250 /* ms */) {
		// kmlEvent.getAltitude() is ground level, but we'll defer to our data
    add_point_drv(kmlEvent.getLatitude(), kmlEvent.getLongitude());
    draw_transects();
  }
}


function editing_3d() {
  return linestring_placemark != null;
}

function start_3d_edit() {
  map.clearOverlays();
  linestring_placemark = ge.createPlacemark('');
  var linestring = ge.createLineString('');
  linestring_placemark.setGeometry(linestring);

  var a = linestring.getCoordinates();
  current.points._foreach(function(p) { a.pushLatLngAlt(p.lat, p.lon, p.elev_data == null? 0 : p.elev - p.elev_data); });
  //linestring.setAltitudeMode(ge.ALTITUDE_ABSOLUTE);
  linestring.setAltitudeMode(ge.ALTITUDE_RELATIVE_TO_GROUND);
  //linestring.setTessellate(true);
  ge.getFeatures().appendChild(linestring_placemark);

  gex.edit.editLineString(linestring, { editCallback: function() {
	if (linestring_timeout_id)
	  clearTimeout(linestring_timeout_id);
	linestring_timeout_id = setTimeout(function() {
	    linestring_timeout_id = null;
            read_linestring();
        }, 500);
  } });
}



function remove_from_map(o) {
  if (o) {
    $m.event.clearInstanceListeners(o);
    o.setMap(null);
  }
}

function near(lat0, lon0, lat1, lon1) {
  return Math.abs(lat1 - lat0) + Math.abs(lon1 - lon0) < .000001;
}

function nearpt(p, lat, lon) {
  return Math.abs(p.lat - lat) + Math.abs(p.lon - lon) < .000001;
}

function nearpt2(p, q) {
  return Math.abs(p.lat - q.lat) + Math.abs(p.lon - q.lon) < .000001;
}


function read_linestring() {
  var a = linestring_placemark.getGeometry().getCoordinates();
  var oldpoints = current.points;
  current.points = [];
  current.total_dist = 0;

  for (var i = 0; i < a.getLength(); i++) {
    var c = a.get(i);
    var clat = c.getLatitude();
    var clon = c.getLongitude();

    for (var oi = 0; ; oi++) {
      if (oi >= oldpoints.length) {
        add_point(c.getLatitude(), c.getLongitude(), null, null, null, null, c.getAltitude());
        break;
      } else {
        var o = oldpoints[oi];
        if (nearpt(o, clat, clon)) {
          add_point(o.lat,
		    o.lon,
	            o.address,
		    o.leg && nearpt2(o.leg.prev, current.points[current.points.length-1])? o.leg : null,
		    o.elev_data,
		    o.elev_override,
		    o.elev_relative,
		    o.pending_route);
	  break;
        }
      }
    }
  }
}


function finish_3d_edit() {
  if (linestring_timeout_id) {
    clearTimeout(linestring_timeout_id);
    linestring_timeout_id = null; 
 }
  if (!linestring_placemark)
    return;
  gex.edit.endEditLineString(linestring_placemark.getGeometry());
  ge.getFeatures().removeChild(linestring_placemark);
  read_linestring();
  linestring_placemark = null;
  reset_current_points();
}
</script>
</head>


<body onload="go()">
<table width="100%" height="100%" cellpadding="10">
  <tr id="toprow">
      <td id="main_title_div" class="maintitle" valign="top">
	HeyWhatsThat&nbsp;Path&nbsp;Profiler
	<!-- <div id="v3_msg">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;We've upgraded the site to Google Maps version 3.  If you have any problems, please <a id="v3_msg_mailto2">contact us</a>.</div> -->
      </td>
      <td id="topbutton_div" align="right" style="white-space:nowrap">
	<!-- <a class="button_ul" target="_blank" href="/help-main.html">Help</a> -->
	<a class="button_ul" href="http://www.heywhatsthat.com">Main&nbsp;site</a>
	<a class="button_ul" href="http://wisp.heywhatsthat.com">WISP&nbsp;tools</a>
	<!-- <a class="button_ul" href="http://wisp.heywhatsthat.com">Fixed&nbsp;Wireless&nbsp;Analysis</a> -->
	<a class="button_ul" href="/eclipse.html">Eclipse&nbsp;simulations</a>
        <a class="button_ul" href="http://www.heywhatsthat.com/faq.html">Site&nbsp;map</a>
	<br>
	<span class="button_ul" onclick="signup()" title="Sign up for email updates">Sign&nbsp;up</span>
	<script>
	  document.writeln('<a class="button_ul" href="mailto:comments-profiler@hey' + 'wh' + 'atsthat.com">Comments?</a>');
	</script>
	<br>
	<a href="http://www.twitter.com/heywhatsthat"><img src="http://twitter-badges.s3.amazonaws.com/t_mini-a.png" alt="Follow @heywhatsthat on Twitter"/></a>
	<span class="g-plusone" data-size="medium" data-annotation="none"></span>
	<iframe src="//www.facebook.com/plugins/like.php?href=http%3A%2F%2Fwww.heywhatsthat.com%2Fprofiler.html&amp;send=false&amp;layout=button_count&amp;width=47&amp;show_faces=false&amp;action=like&amp;colorscheme=light&amp;font&amp;height=21" scrolling="no" frameborder="0" style="border:none; overflow:hidden; width:50px; height:21px; padding-top: 6px; padding-right: 10px" allowTransparency="true" onclick="opener.do_not_close_sponsor_pane()"></iframe>
        <img src="images/dollarsign.png" onclick="window.open('http://www.heywhatsthat.com/donate.html?service=profiler')" title="Make a contribution" alt="$$"/>



<!--
  if (use_ge)
    new WTControl(topbutton_div, 0, answerbutton_enable, null, "This test page without loading Google Earth", null, function() { location.href = '/profiler-0904.html?noearth=1';});
  else
    new WTControl(topbutton_div, 0, answerbutton_enable, null, "This test page with Google Earth API loaded", null, function() { location.href = '/profiler-0904.html?earth=1';});
  
  var pp = new WTControl(topbutton_div, 0, answerbutton_enable, null, "Print", "use profiler-0904.html?printcomments=1 if you also want comment fields for the points", function() { set_print(1) });


  transect0_widget.trigger(1);
  //transect1_widget.trigger(1);
-->

  </tr>
  <tr id="print" style="display:none"><td>
    <input type=text class=maintitle size=80>
    <div style="text-align:right" onclick="set_print(0)"><img src="/images/hwtcom-logo-238-35.jpg">
    &nbsp;&nbsp;X
    </div>
  </td></tr>

  <!-- <tr><td id="widen_window" colspan="2" align="right" class="button_ul" onclick="wider_map(100)">Wider map</td></tr>
       <tr><td id="lengthen_window" colspan="2" align="right" class="button_ul" onclick="taller_map(100)">Taller map</td></tr> -->
  <tr><td id="transect0_widget" colspan="2" align="right" class="button_ul wtbutton" onclick="wtbutton_toggle(this)" data-text-0="Show profile 1" data-text-1="Hide profile 1" data-exec="transect0_pane.style.display = val - 0? '' : 'none'; map_resize(); check_elev_sources();"></td></tr>
  <tr id="transect0_pane"><td colspan="2" align="center">
	<img id="transect0_img" style="border:1px solid black">
	<br>
	<form name="f_transect0" onsubmit="return false">
	  <span id="transect0_parms_widget" class="button wtbutton" onclick="wtbutton_toggle(this)" data-img-0="/images/lclpsd-blue.png" data-img-1="/images/expdd-blue.png" data-exec="display('transect0_parms_pane', val - 0); map_resize();"><img/> Parameters</span>
	  <table border=1 id="transect0_parms_pane" cellpadding="5">
	    <tr>
	      <td>
		<input type="checkbox" name="axes" onclick="draw_transect(0)">show scale
		<br>
		<input type="checkbox" name="colored_lines" onclick="draw_transect(0)">show lines
	      </td><td>
		<input type="radio" name="los" value="0" onclick="draw_transect(0)" checked>straight line
		<br>
		<input type="radio" name="los" value="1" onclick="draw_transect(0)">true line of sight
	      </td><td>
		fixed exaggeration (e.g. 2) <input type="text" name="exaggeration" size=10 onchange="draw_transect(0)">
	      </td>
	    </tr>
	    <tr>
	      <td>
		<input type="radio" name="curvature" value="0" onclick="draw_transect(0)" checked>flat Earth
		<br>
		<input type="radio" name="curvature" value="1" onclick="draw_transect(0)">curved Earth
	      </td><td>
		frequency (MHz, e.g. 5800)<br><input type="text" name="freq" size=10 onchange="draw_transect(0)">
	      </td><td>
		y range (e.g. -20,100) <input type="text" name="yrange" size=10 onchange="draw_transect(0)">
	      </td>
	    </tr>
	    <tr>
	      <td>
		<input type="radio" name="path" value="0" onclick="draw_transect(0)" checked>plate car&eacute;e
		<br>
		<input type="radio" name="path" value="1" onclick="draw_transect(0)">great circle
	      </td><td>
		refraction (e.g. .14)<br><input type="text" name="refraction" size=10 onchange="draw_transect(0)">
	      </td><td align="center">
		<input type="hidden" name="elev_source" value="0">
		<!-- TK
		     elevation data source<br>
		     <input type="radio" name="elev_source" value=0 onclick="set_elev_source(0);draw_transect(0)" checked>SRTM
		     <input type="radio" name="elev_source" value=1 onclick="set_elev_source(0);draw_transect(0)">Google
		     -->
		<!-- when you reinstate google data, move Reset button back out of the box -->
		<span class="button_ul" onclick="reset_transect_parms(0)" title="Reset profile parameters">Reset</span>
	      </td>
	    </tr>
	  </table>
	</form>
  </td></tr>
  <tr><td id="transect1_widget" colspan="2" align="right" class="button_ul wtbutton" onclick="wtbutton_toggle(this)" data-text-0="Show profile 2" data-text-1="Hide profile 2" data-exec="transect1_pane.style.display = val - 0? '' : 'none'; map_resize(); check_elev_sources();"></td></tr>
  <tr id="transect1_pane" style="display: none"><td colspan=2 align="center">
	<img id="transect1_img" style="border:1px solid black">
	<br>
	<form name="f_transect1" onsubmit="return false">
	  <span id="transect1_parms_widget" class="button wtbutton" onclick="wtbutton_toggle(this)" data-img-0="/images/lclpsd-blue.png" data-img-1="/images/expdd-blue.png" data-exec="display('transect1_parms_pane', val - 0); map_resize();"><img/> Parameters</span>
	  </span>
	  <table border=1 id="transect1_parms_pane" cellpadding="5">
	    <tr>
	      <td>
		<input type="checkbox" name="axes" onclick="draw_transect(1)">show scale
		<br>
		<input type="checkbox" name="colored_lines" onclick="draw_transect(1)">show lines
	      </td><td>
		<input type="radio" name="los" value="0" onclick="draw_transect(1)" checked>straight line
		<br>
		<input type="radio" name="los" value="1" onclick="draw_transect(1)">true line of sight
	      </td><td>
		fixed exaggeration (e.g. 2) <input type="text" name="exaggeration" size=10 onchange="draw_transect(1)">
	      </td>
	    </tr>
	    <tr>
	      <td>
		<input type="radio" name="curvature" value="0" onclick="draw_transect(1)" checked>flat Earth
		<br>
		<input type="radio" name="curvature" value="1" onclick="draw_transect(1)">curved Earth
	      </td><td>
		frequency (MHz, e.g. 5800)<br><input type="text" name="freq" size=10 onchange="draw_transect(1)">
	      </td><td>
		y range (e.g. -20,100) <input type="text" name="yrange" size=10 onchange="draw_transect(1)">
	      </td>
	    </tr>
	    <tr>
	      <td>
		<input type="radio" name="path" value="0" onclick="draw_transect(1)" checked>plate car&eacute;e
		<br>
		<input type="radio" name="path" value="1" onclick="draw_transect(1)">great circle
	      </td><td>
		refraction (e.g. .14)<br><input type="text" name="refraction" size=10 onchange="draw_transect(1)">
	      </td><td align="center">
		<input type="hidden" name="elev_source" value="0">
		<!-- TK
		     elevation data source<br>
		     <input type="radio" name="elev_source" value=0 onclick="set_elev_source(0);draw_transect(1)" checked>SRTM
		     <input type="radio" name="elev_source" value=1 onclick="set_elev_source(0);draw_transect(1)">Google
		     -->
		<span class="button_ul" onclick="reset_transect_parms(1)" title="Reset profile parameters">Reset</span>
	      </td>
	    </tr>
	  </table>
	</form>
  </td></tr>

  <tr id="google_options_div" class="inputcomment" style="display:none"><td align=center colspan="2">
  Many of the profile options are not available when viewing Google elevation data
  </td></tr>

  <tr><td align=center colspan="2">
      <form name="f_units" onsubmit="return false">
	<input type="radio" name="units" value="0" onclick="set_units(0)">English
	<input type="radio" name="units" value="1" onclick="set_units(1)">Metric
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	Decimal places (0-6) <input type="text" name="decimalplaces" size=10 onchange="set_decimal_places(this.value)">
	&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
	<input type="radio" name="degrees_format" value="0" onclick="set_degrees_format(this.value)">DD.DDDDDD&deg;
	<input type="radio" name="degrees_format" value="1" onclick="set_degrees_format(this.value)">DD&deg; MM.MMMM'
	<input type="radio" name="degrees_format" value="2" onclick="set_degrees_format(this.value)">DD&deg; MM' SS.SS&quot;

<!-- TK
      <span class=button_ul onclick="show_popup($$('import_div'), 400, 100)">Import path</span>
-->
      </form>

<!-- TK
    <div id="import_div" class="popup" style="display:none">
      <hr>
      <form name="f_import" enctype="multipart/form-data" onsubmit="return false" style="text-align:center">
	To upload a KML file, choose a file: <input name="kmlfile" type="file"/>
        <br>
        To use a KML file that's already on the web or a Google Maps link, enter it:
        <input type="text" name="url" size=20 onchange="import_url_or_msid(this.value)"/>
        <br>
        <span class=button_ul onclick="import_url_or_msid()">Import</span>
	&nbsp;&nbsp;&nbsp;&nbsp;
        <span class=button_ul onclick="close_popup($$('import_div'))">Cancel</span>
        <p>
        <div class=inputcomment>If there are other formats you'd be interested in, drop us a line</div>
	<input name="elev_source" type=hidden />
	<input name="max_points" type=hidden />
      </form>
      <hr>
    </div>
-->

  </td></tr>
  <tr><td>&nbsp;</td></tr>
  <tr height="100%">
			<!-- for firefox, map_div can't be a TD -->
      <td valign="top" height="100%" width="100%"><div id="map_div" style="width:100%;height:100%"></div></td>
      <td id="list_pane" align="right" valign="top" style="white-space: nowrap">
	  <form name="f_list_pane" id="list_pane_form" onsubmit="return false">
	    <span class="button_ul" onclick="handle_location()" title="Add this address as next point">Find:</span> <input name=location size=30 onchange="handle_location()">
	    <br>
	    <span class="button_ul" onclick="draw_transect(0,1);draw_transect(1);">Draw&nbsp;profiles</span>
	    <br>
	    <span class="button_ul" onclick="clear_points()" title="Remove all points">Clear</span>
	    <span class="button_ul" onclick="backspace()" title="Remove last point">Backspace</span>
	    <span class="button_ul" onclick="checkpoint()">Checkpoint</span>
	    <br>
	    <!--
		edit3d = new WTControl(listbutton_div, 2, function(d) {d.style.display=''}, function(d) {d.style.display='none'},
		function(x) { return x? "line edit done" : "line edit"}, null, function(x) { if (x) start_3d_edit(); else finish_3d_edit(); });
		edit3d.div.className = 'button_ul';
		edit3d.disable();
	      -->

	    <span class="checkbox_text">
	      <input id="driving_route" type="checkbox" onclick="set_driving_route(this.checked - 0, 0)">follow&nbsp;driving&nbsp;route
	    </span>
            <!--
	    <span class="checkbox_text">
	      <input id="driving_route_piecewise" type="checkbox" onclick="set_driving_route(this.checked - 0, 1)">follow&nbsp;driving&nbsp;route&nbsp;piecewise
	    </span>
	    -->
	    <span class="checkbox_text" title="shows change in elevation, % rise/run, and visual altitude (latter includes earth curvature and refraction)">
	      <input id="show_grade" type="checkbox" onclick="set_show_grade(this.checked - 0)">show&nbsp;grade
	    </span>
	    <br>
            <span class="checkbox_text">
	      <input id="show_rise" type="checkbox" onclick="set_show_rise(this.checked - 0)">show&nbsp;rise/fall
	    </span>
	    <span id="include_grade_span" class="checkbox_text" title="include vertical change in distance between points listed below; note that profile images never include vertical change in distance">
	      <input id="include_grade" type="checkbox" onclick="set_include_grade(this.checked - 0)">include&nbsp;grade&nbsp;in&nbsp;distance
	    </span>
	    <br><i style="padding-right: 10px">Bearings are true, not magnetic</i>
	    <br>&nbsp;
	  </form>
	  <div id="elev_source_div" class="button_comment" title="this table shows elevations for the first profile" style="display:none">SRTM elevation data</div>
	<div id="list_div"></div>
      </td>
  </tr>
  <tr><td id="map_latlon_div" class="maplatlon" align="center" title="click to change lat/lon format" onclick="set_degrees_format((settings.degrees_format + 1) % 3)"></td></tr>

  <tr><td id="ads_pane" class="ads" colspan="2" align="center">
      <script type="text/javascript">
	google_ad_client = "pub-2630458079197795";
	/* 728x90, created 7/21/08 */
	google_ad_slot = "0161708191";
	google_ad_width = 728;
	google_ad_height = 90;
      </script>
      <script type="text/javascript" src="http://pagead2.googlesyndication.com/pagead/show_ads.js"></script>
  </td></tr>
  <script type="text/javascript">
    (function() {
    var po = document.createElement('script'); po.type = 'text/javascript'; po.async = true;
    po.src = 'https://apis.google.com/js/plusone.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(po, s);
    })();
  </script>
</table>
</body>
</html>
